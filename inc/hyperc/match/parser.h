// hyperc/match/parser.h

#ifndef METAC_MATCH_PARSER_H
#define METAC_MATCH_PARSER_H




/* (kinda cool)

# Arity Series (latin)

    0 - Nullary
    1 - Unary
    2 - Binary
    3 - Ternary
    4 - Quaternary


# Adicity Series (greek)

    0 - Niladic
    1 - Monadic
    2 - Dyadic
    3 - Triadic
    4 - Tetradic

*/



#include <stdint.h>

#include "hyperc/parser.h"




#define TYPE_FLAGS 0
#define TYPE_A  1
#define TYPE_B  2
#define TYPE_C  3
#define TYPE_D  4
#define TYPE_E  5
#define TYPE_F  6
#define TYPE_G  7
#define TYPE_H  8
#define TYPE_I  9
#define TYPE_J  10
#define TYPE_K  11
#define TYPE_L  12
#define TYPE_M  13
#define TYPE_N  14
#define TYPE_O  15
#define TYPE_P  16
#define TYPE_Q  17
#define TYPE_R  18
#define TYPE_S  19
#define TYPE_T  20
#define TYPE_U  21
#define TYPE_V  22
#define TYPE_W  23
#define TYPE_X  24
#define TYPE_Y  25
#define TYPE_Z  26



// #define MF_FLAG_MASK    ( 0xFFFF0000 )
// #define MF_FLAG_SHIFT   16
// #define MF_MATCH_MASK   ( 0x0000FFFF )
// #define MF_OPTIONAL     ( 0b1<<16 )     // maybe flags like this can be handled by the input handler...
// //#define MF_ZERO_OR_ONE  ( 0b1<<16 )
// //#define MF_ZERO_OR_MORE ( 0b1<<17 )
// //#define MF_ONE_OR_MORE  ( 0b1<<18 )
// #define MF_UTOKEN       ( 0b1<<19 )     // ...since these would be handled by the input handler as well
// #define MF_DTOKEN       ( 0b1<<20 )
// #define MF_TOKEN_TYPE   ( 0b1<<21 )
// #define MF_COLLAPSE     ( 0b1<<22 )
// 
// #define MF_OUT_MASK     ( 0b1111<<23 )
// #define MF_OUT_SHIFT    23
// 
// #define MF_NOT_IMPLEMENTED ( 0b1<<31 )



#define MF_UTOKEN       ( 0b1<<16 )     // ...since these would be handled by the input handler as well
#define MF_DTOKEN       ( 0b1<<17 )
#define MF_TOKEN_TYPE   ( 0b1<<18 )
//#define MF_CONDENSE     ( 0b1<<19 )

#define MF_OUT_MASK     ( 0b1111<<23 )
#define MF_OUT_SHIFT    23


// TODO: what was this for again?
#define OUT_0   (  0<<MF_OUT_SHIFT )
#define OUT_1   (  1<<MF_OUT_SHIFT )
#define OUT_2   (  2<<MF_OUT_SHIFT )
#define OUT_3   (  3<<MF_OUT_SHIFT )
#define OUT_4   (  4<<MF_OUT_SHIFT )
#define OUT_5   (  5<<MF_OUT_SHIFT )
#define OUT_6   (  6<<MF_OUT_SHIFT )
#define OUT_7   (  7<<MF_OUT_SHIFT )
#define OUT_8   (  8<<MF_OUT_SHIFT )
#define OUT_9   (  9<<MF_OUT_SHIFT )
#define OUT_10  ( 10<<MF_OUT_SHIFT )
#define OUT_11  ( 11<<MF_OUT_SHIFT )
#define OUT_12  ( 12<<MF_OUT_SHIFT )
#define OUT_13  ( 13<<MF_OUT_SHIFT )
#define OUT_14  ( 14<<MF_OUT_SHIFT )
#define OUT_15  ( 15<<MF_OUT_SHIFT )






enum {
    //MATCH_END = 0,
    // use NULL or 0

    ///////////////////////
    MATCH_IDENTIFIER = 1,
    MATCH_CONSTANT,
    MATCH_STRING_LITERAL,
    MATCH_WHITESPACE,
    MATCH_DIRECTIVE,
    MATCH_COMMENT,
    MATCH_ENUMERATION_CONSTANT,

    // EXPRESSIONS
    MATCH_PRIMARY_EXPRESSION,
    //MATCH_POSTFIX_EXPRESSION_ALT,
    //MATCH_POSTFIX_OPERATOR,
    MATCH_POSTFIX_EXPRESSION,
    MATCH_ARGUMENT_EXPRESSION_LIST,
    MATCH_COMPOUND_LITERAL,
    MATCH_STORAGE_CLASS_SPECIFIERS,
    MATCH_UNARY_EXPRESSION,
    MATCH_UNARY_OPERATOR,
    MATCH_CAST_EXPRESSION,
    MATCH_MULTIPLICATIVE_EXPRESSION,
    MATCH_ADDITIVE_EXPRESSION,
    MATCH_SHIFT_EXPRESSION,
    MATCH_RELATIONAL_EXPRESSION,
    MATCH_EQUALITY_EXPRESSION,
    MATCH_AND_EXPRESSION,
    MATCH_EXCLUSIVE_OR_EXPRESSION,
    MATCH_INCLUSIVE_OR_EXPRESSION,
    MATCH_LOGICAL_AND_EXPRESSION,
    MATCH_LOGICAL_OR_EXPRESSION,
    MATCH_CONDITIONAL_EXPRESSION,
    MATCH_ASSIGNMENT_EXPRESSION,
    MATCH_ASSIGNMENT_OPERATOR,
    MATCH_EXPRESSION,
    MATCH_CONSTANT_EXPRESSION,

    // DECLARATIONS
    MATCH_DECLARATION,
    MATCH_DECLARATION_SPECIFIERS,
    MATCH_DECLARATION_SPECIFIER,
    MATCH_INIT_DECLARATOR_LIST,
    MATCH_INIT_DECLARATOR,
    MATCH_ATTRIBUTE_DECLARATION,    // NOT IMPLEMENTED
    MATCH_STORAGE_CLASS_SPECIFIER,
    MATCH_TYPE_SPECIFIER,
    MATCH_STRUCT_OR_UNION_SPECIFIER,
    MATCH_STRUCT_OR_UNION,
    MATCH_MEMBER_DECLARATION_LIST,
    MATCH_MEMBER_DECLARATION,
    MATCH_SPECIFIER_QUALIFIER_LIST,
    MATCH_TYPE_SPECIFIER_QUALIFIER,
    MATCH_MEMBER_DECLARATOR_LIST,
    MATCH_MEMBER_DECLARATOR,
    MATCH_ENUM_SPECIFIER,
    MATCH_ENUMERATOR_LIST,
    MATCH_ENUMERATOR,
    MATCH_ENUM_TYPE_SPECIFIER,
    MATCH_ATOMIC_TYPE_SPECIFIER,
    MATCH_TYPEOF_SPECIFIER,
    MATCH_TYPEOF_SPECIFIER_ARGUMENT,
    MATCH_TYPE_QUALIFIER,
    MATCH_FUNCTION_SPECIFIER,
    MATCH_ALIGNMENT_SPECIFIER,
    MATCH_DECLARATOR,
    MATCH_DIRECT_DECLARATOR,
    MATCH_ARRAY_DECLARATOR,
    MATCH_FUNCTION_DECLARATOR,
    MATCH_POINTER,
    MATCH_TYPE_QUALIFIER_LIST,
    MATCH_PARAMETER_TYPE_LIST,
    MATCH_PARAMETER_LIST,
    MATCH_PARAMETER_DECLARATION,
    MATCH_TYPE_NAME,
    MATCH_ABSTRACT_DECLARATOR,
    MATCH_DIRECT_ABSTRACT_DECLARATOR,
    MATCH_ARRAY_ABSTRACT_DECLARATOR,
    MATCH_FUNCTION_ABSTRACT_DECLARATOR,
    MATCH_TYPEDEF_NAME,
    MATCH_BRACED_INITIALIZER,
    MATCH_INITIALIZER,
    MATCH_INITIALIZER_LIST,
    MATCH_DESIGNATION,
    MATCH_DESIGNATOR_LIST,
    MATCH_DESIGNATOR,
    MATCH_STATIC_ASSERT_DECLARATION,
    MATCH_ATTRIBUTE_SPECIFIER_SEQUENCE, // NOT IMPLEMENTED
    MATCH_ATTRIBUTE_SPECIFIER,          // NOT IMPLEMENTED
    MATCH_ATTRIBUTE_LIST,               // NOT IMPLEMENTED
    MATCH_ATTRIBUTE,                    // NOT IMPLEMENTED
    MATCH_ATTRIBUTE_TOKEN,              // NOT IMPLEMENTED
    MATCH_STANDARD_ATTRIBUTE,           // NOT IMPLEMENTED
    MATCH_ATTRIBUTE_PREFIX_TOKEN,       // NOT IMPLEMENTED
    MATCH_ATTRIBUTE_PREFIX,             // NOT IMPLEMENTED
    MATCH_ATTRIBUTE_ARGUMENT_CLAUSE,    // NOT IMPLEMENTED
    MATCH_BALANCED_TOKEN_SEQUENCE,      // NOT IMPLEMENTED
    MATCH_BALANCED_TOKEN,               // NOT IMPLEMENTED

    // STATEMENTS
    MATCH_STATEMENT,
    MATCH_UNLABELED_STATEMENT,
    MATCH_PRIMARY_BLOCK,
    MATCH_SECONDARY_BLOCK,
    MATCH_LABEL,
    MATCH_LABELED_STATEMENT,
    MATCH_COMPOUND_STATEMENT,
    MATCH_BLOCK_ITEM_LIST,
    MATCH_BLOCK_ITEM,
    MATCH_EXPRESSION_STATEMENT,
    MATCH_SELECTION_STATEMENT,
    MATCH_ITERATION_STATEMENT,
    MATCH_JUMP_STATEMENT,

    // EXTERNAL DEFINITIONS
    MATCH_TRANSLATION_UNIT,     // PRIME MATCHING RULE
    MATCH_EXTERNAL_DECLARATION,
    MATCH_FUNCTION_DEFINITION,
    MATCH_FUNCTION_BODY,

    ///////////////////////
    MATCH_RULE_LEN
};
typedef uint32_t match_id_t;




extern const char *const match_type_str[TYPE_Z+1];
extern const char *const match_rule_str[MATCH_RULE_LEN];

extern static_tree_t c_mtree;




#endif /* #ifndef METAC_MATCH_PARSER_H */
