-- buildtree module

-- The question is, what is different between each output file
-- We got shared and separate flags. We got different source directories
-- We got shared source directories




local self = {}




local enum = {
    meta = {
        __index = function(self, key)
            return key
        end
        __newindex = function(table, key, value)
            print("writing to ext table not allowed")
        end
    },
}
setmetatable(ext, ext.meta)
local self.enum = enum
local self.ext  = enum
local self.type = enum



local function defmode()
    return {type = {}, file = {}}
end


local function deftype()
    return {builder = {}, options = {}}
end


local gopts = {
    all = newmode(),
    
    -- register = function(self, mode) {
    --     if type(t) ~= "table" then mode = {mode} end
    --     
    --     for key, value in pairs(t) do
    --         self[value] = {type = {}, file = {}}
    --     end
    -- }
}


gopts.fast    = defmode()
gopts.debug   = defmode()
gopts.release = defmode()


gopts.all.type[ext.c] = deftype()


-- for every file being compiled in our entire dependancy tree, what do we
-- ultimately need?
-- inputs, outputs, options, compiler

-- I need a descriptor that can specify global options per type, while also
-- 

--[[
Heiarchy:
desc
    all
        type
            [typename]
                *desc*
                    
        file
            [typename]
                *desc*
    [modes]
        type
                [typename]
                    *desc*
                    
        file
                [typename]
                    *desc*
]]--


--[[
Heiarchy:
desc
    [modes]
        type[typenames]
            global
                *desc*
            local
                [filename]
                    *desc*
]]--



--[[

Final build table heiarchy

build
    [target] (path)
        depend
            [dependancy] (path)
        builder (callback)
        opts
        flags (for the makefile, not the compiler)
            force_rebuild



We need a way to differentiate between
dependancies that need to be built
and dependancies that already exist.
I suppose a dependancy with no dependancies
is ready to be built, and we just look at 
the date of the existing file pointed
to by the target. And if it exists.
So alright, I guess that would do it.


But generally, I should try to add functions that will
generate this list for us.

First, we should have a function that recursively
pulls in files from a directory that will assign compiler,
generate dependancies, and set options.
We also need an output destination to generate the targets


The buildtree will be built according to the mode.


]]--


local function cmd(command)
    local handle = io.popen(command)
    local out = handle:read("*a")
    local ok, stat = handle:close()
    return out
end






-- separate string into table using separator
local stringmt = getmetatable("", strip)
stringmt.__index.split = function(self, sep)
    if sep == nil then sep = " " end
    if sep == "" then return self end

    local out = {}
    local index = 1
    local last = 1
    while true do
        start, stop = self:find(sep, index, true)
        if not start then break end
        out:insert(self:sub(last, start-1))
        index = stop + 1
        last = index
    end
    out:insert(self:sub(last))

    if strip == true then
        for key, value in pairs(out) do
            out[key] = value:strip()
        end
    end

    return out
end

-- strip string of whitespace
stringmt.__index.strip = function(self)
    return self:gsub("^%s+", ""):gsub("%s+$", "")
end





local fs = {
    ls = function(path)
        if path == nil then path = "."
        local out = cmd("ls \""..path.."\""):split(' ', true)
    end,
    
    cd = function(path)
        if path == nil then path = "~"
        return cmd("cd \""..path.."\"")
    end,

    pwd = function()
        return cmd("pwd -P")
    end,

    type = function(path)
        return cmd("file -b \""..path.."\"")
    end,

    fullpath = function(path)
        return cmd("realpath \""..path.."\"")
    end,

    getsuffix = function(path)
        local index = path:reverse():find('.', 1, true)
        index = #path - index + 2
        return i and path:sub(index) or ""
    end,

    nearpath = function(base, path)
        return cmd("realpath --relative-to=\""..base.."\" \""..path.."\"")
    end
}


--[[
Final build table heiarchy

build
    target[target] (path)
        depends
            [dependancy] (path)
        builder (callback)
        opts
        flags (for the makefile, not the compiler)
            force_rebuild
]]--

-- fill tree with files from indir, filter by type, using build and dependancy
-- callbacks, and target outdir for each file
local function filltree(self, indir, outdir, type, options, depend_call, typetable)
    if options == nil then options = "" end
    if depend_call == nil then depend_call = function() return {} end

    -- have a typetable with a bunch of known types, and a way to register more
    -- if typetable == nil then typetable = self.types or default.types
    if typetable == nil then typetable = self.types
    -- types.ftype(path)
    -- types[ext.c].build(path, opts)

    -- default callbacks
    --if type_call == nil   then type_call   = self.default.type_call
    --if filter_call == nil then filter_call = self.default.filter_call
    --if depend_call == nil then depend_call = self.default.depend_call
    --if build_call == nil  then build_call  = self.default.build_call

    -- get current directory
    local list = fs.ls(indir)

    local unused_dirs = {}
    local target_keys = {}

    -- loop over all files in directory
    for key, value in pairs(list)
        local fpath = fs.fullpath(indir.."/"..value)

        -- skip file if directory or doesn't match type
        if fs.type(fpath) == "directory" then
            unused_dirs:insert(fpath)
            goto skip
        end
        
        -- setup descriptor
        self.target[fpath] = {
            type = type
            -- replace with type descriptors with build info
            -- build_call = build_call
            options = options
            flags = {}
            -- get file dependancies, pass in file type
            depends = depend_call(fpath, type)
        }

        target_keys:insert(fpath)
        
        ::skip::
    end

    -- for use of rfilltree recursive function
    return target_keys, unused_dirs
end



-- like filltree, but reads from directories recursively. The outdir tree mimics
-- the indir tree structure in order to avoid naming conflicts.
local function rfilltree(self, indir, outdir, type, options, build_call, depend_call)
    _, cdirs = self:filltree(self, indir, outdir, type, options, 
                        build_call, depend_call)

    for _, newindir in pairs(child_dirs)
        local newoutdir = outdir.."/"..fs.nearpath(indir, newindir)
        rfilltree(self, newindir, newoutdir, type, options, build_call, depend_call)
    end
end



-- local function default_type_call(path)
--     return ext[fs.getsuffix(path)]
-- end



function newbuildtree()
    return {
        filltree = filltree,
        rfilltree = rfilltree,

        -- default = {
        --     type_call   = default_type_call,
        --     filter_call = default_filter_call,
        --     depend_call = default_depend_call,
        --     build_call  = default_build_call,
        -- },
    }
end



local buildtree = newbuildtree()







local desc = {
    type = {}, -- per type descriptors
    file = {}, -- per file descriptors
}

local function run(args)
    local targets = {}
    
        -- type inputs output options dependancies
    targets[1] = {}
    targets[1].type    = enum.EXE
    targets[1].inputs  = fsrcpullr(dir.src.."/exe", ".c")
    targets[1].output  = "hyper"
    targets[1].options = ""
    targets[1].depend  = {}

    targets[2] = {}
    targets[2].type    = enum.LIB
    targets[2].inputs  = fsrcpullr(dir.src.."/lib", ".c")
    targets[2].output  = "hyper.so"
    targets[2].options = defopts
    targets[2].options[ext.c] = defopts.c .. ""
    targets[2].depend  = {}
end



local function fsrcpullr(path, ext)
    return fmatchtype(flistr(path), ext)
end


-- It would be neat for each separate source directory to have a descriptor
-- for how we want them to compile, and then have a super generalized lua file
-- read those to compile everything.
-- There is one problem though, which is that two outputs can share source files.
-- I was considering having everything just be shared source files and then flags
-- further determine separation via in-source preprocessor guards, etc.
-- However, that relies on the compiler being able to remove unused code.
-- So I guess a shared source code directory is the way to go.


-- Should this be directory based or file based, where I have functions that can 
-- collect files based on directory?
-- In that case, what do we need to know? 
-- We need source files, output path, the temp stuff can probably be handled 
-- automatically. But we do need dependancies.


--[[ 
Need:
 - Source files
 - Output files
 - [name of temp dir]
 - Dependancies
 - Descriptors of output or temp types
 - flags or command modifiers


Ideally we want a way to define a function that defines how an output type
is handled.
]]--
