-- buildtree module


local module = {}



local enum = {
    meta = {
        __index = function(self, key)
            return key
        end
        __newindex = function(table, key, value)
            print("writing to ext table not allowed")
        end
    },
}
setmetatable(ext, ext.meta)

module.enum = enum
module.ext  = enum
module.type = enum





local function cmd(command)
    local handle = io.popen(command)
    local out = handle:read("*a")
    local ok, stat = handle:close()
    return out
end

module.cmd = cmd





-- separate string into table using separator
-- adds this behavior to the main string metatable
local stringmt = getmetatable("", strip)
stringmt.__index.split = function(self, sep)
    if sep == nil then sep = " " end
    if sep == "" then return self end

    local out = table.new()
    local index = 1
    local last = 1
    while true do
        start, stop = self:find(sep, index, true)
        if not start then break end
        out:insert(self:sub(last, start-1))
        index = stop + 1
        last = index
    end
    out:insert(self:sub(last))

    if strip == true then
        for key, value in pairs(out) do
            out[key] = value:strip()
        end
    end

    return out
end

-- strip string of whitespace
-- adds method to main string metatable
stringmt.__index.strip = function(self)
    return self:gsub("^%s+", ""):gsub("%s+$", "")
end



table.copy = function(t)
    rt = {}
    for key, value in pairs do
        rt[key] = value
    end
    return rt
end

table.new = function(rtable)
    if rtable == nil then rtable = {} end
    return setmetatable(table.copy(rtable), table)
end

-- implement later
-- table.slice = function(t, first, last)
--     if first < 0
-- end




-- linux file system helper
local fs = {
    ls = function(path)
        if path == nil then path = "."
        local out = cmd("ls \""..path.."\""):split(' ', true)
    end,
    
    cd = function(path)
        if path == nil then path = "~"
        return cmd("cd \""..path.."\"")
    end,

    pwd = function()
        return cmd("pwd -P")
    end,

    get_type = function(path)
        return cmd("file -b \""..path.."\"")
    end,

    get_fullpath = function(path)
        return cmd("realpath \""..path.."\"")
    end,

    -- get file extension from name
    get_ext = function(path)
        local index = path:reverse():find('.', 1, true)
        index = #path - index + 2
        return i and path:sub(index) or ""
    end,

    get_name = function(path)
        return cmd("basename \""..path.."\"")
    end,

    -- returns path relative to base
    get_nearpath = function(base, path)
        return cmd("realpath --relative-to=\""..base.."\" \""..path.."\"")
    end,

    is_dir = function(path)
        return cmd("test -d \""..path.."\" && echo 1 || echo 0") == "1"
    end,

    --is_ext = function(path, ext) end
}

fs.find = function(path, is_recursive, filter)
    if is_recursive == nil then is_recursive = false

    if not fs.is_dir(path) then
        print("fs.find(...): \""..path.."\" is not a directory")
        
    local dirs = table.new({path})
    local files = table.new()

    while #dirs ~= 0 do
        local _, dpath = next(dirs)
        if dpath == nil then break end
        
        for _, fpath in pairs(fs.ls(dpath)) do
            if fs.is_dir(fpath) then
                dirs:insert(fpath)
            elseif filter(fs.get_ext(fpath)) then
                files:insert(fpath)
            end
        end
    end
end

module.fs = fs


filter = {
    ext = function(ext)
        return function(path)
            return fs.get_ext(path) == ext
        end
    end,

    name = function(name)
        return function(path)
            return fs.get_name(path) == name
        end
    end,
}


module.filter = filter




--[[
Final build table heiarchy

build
    target[target] (path)
        depends
            [dependancy] (path)
        builder (callback)
        opts
        flags (for the makefile, not the compiler)
            force_rebuild
]]--

-- fill tree with files from indir, filter by type, using build and dependancy
-- callbacks, and target outdir for each file
module.filltree = function(self, indir, outdir, type, options, depend_call)
    if options == nil then options = "" end
    if depend_call == nil then depend_call = function() return {} end

    -- have a typetable with a bunch of known types, and a way to register more
    -- if typetable == nil then typetable = self.types or default.types
    -- if typetable == nil then typetable = self.types
    -- types.ftype(path)
    -- types[ext.c].build(path, opts)
    typemap = self.typemap
    if typemap == nil then
        print("typemap not set")
        return
    end

    -- default callbacks
    --if type_call == nil   then type_call   = self.default.type_call
    --if filter_call == nil then filter_call = self.default.filter_call
    --if depend_call == nil then depend_call = self.default.depend_call
    --if build_call == nil  then build_call  = self.default.build_call

    -- get current directory
    local list = fs.ls(indir)

    local unused_dirs = {}
    local target_keys = {}

    -- loop over all files in directory
    for key, value in pairs(list)
        local fpath = fs.fullpath(indir.."/"..value)

        -- skip file if directory or doesn't match type
        if fs.type(fpath) == "directory" then
            unused_dirs:insert(fpath)
            goto skip
        end
        
        -- setup descriptor
        self.target[fpath] = {
            type = type
            -- replace with type descriptors with build info
            -- build_call = build_call
            options = options
            flags = {}
            -- get file dependancies, pass in file type
            depends = depend_call(fpath, type)
        }

        target_keys:insert(fpath)
        
        ::skip::
    end

    -- for use of rfilltree recursive function
    return target_keys, unused_dirs
end



-- like filltree, but reads from directories recursively. The outdir tree mimics
-- the indir tree structure in order to avoid naming conflicts.
module.rfilltree = (self, indir, outdir, type, options, build_call, depend_call)
    _, cdirs = self:filltree(self, indir, outdir, type, options, 
                        build_call, depend_call)

    for _, newindir in pairs(child_dirs)
        local newoutdir = outdir.."/"..fs.nearpath(indir, newindir)
        rfilltree(self, newindir, newoutdir, type, options, build_call, depend_call)
    end
end



-- local function default_type_call(path)
--     return ext[fs.getsuffix(path)]
-- end



module.newtree = function()
    return {
        filltree = filltree,
        rfilltree = rfilltree,

        -- default = {
        --     type_call   = default_type_call,
        --     filter_call = default_filter_call,
        --     depend_call = default_depend_call,
        --     build_call  = default_build_call,
        -- },
    }
end




module.default = {}





-- describes the known types, and what compiler is used to compile them
typemap = {
  
  -- describes to build system how to build exe
  [ext.exe] = {
    builder = function(outpath, infiles, opts)
        cmd("gcc -o "..outpath.." "..tostring(infiles).." "..opts)
    end
    depender = function(path, type, opts)
        cmd("gcc -MMD ")
    end
  },

  -- describes to build system how to build object
  [ext.object] = {
    builder = function(path, infiles, opts)
      cmd("gcc -c -o "..path.." "..tostring(infiles).." "..opts)
    end
  },
  filetype = default.filetype -- callback
}

module.default.gcc_typemap = typetable






-- local function run(args)
--     local targets = {}
--     
--         -- type inputs output options dependancies
--     targets[1] = {}
--     targets[1].type    = enum.EXE
--     targets[1].inputs  = fsrcpullr(dir.src.."/exe", ".c")
--     targets[1].output  = "hyper"
--     targets[1].options = ""
--     targets[1].depend  = {}
-- 
--     targets[2] = {}
--     targets[2].type    = enum.LIB
--     targets[2].inputs  = fsrcpullr(dir.src.."/lib", ".c")
--     targets[2].output  = "hyper.so"
--     targets[2].options = defopts
--     targets[2].options[ext.c] = defopts.c .. ""
--     targets[2].depend  = {}
-- end



-- local function fsrcpullr(path, ext)
--     return fmatchtype(flistr(path), ext)
-- end




return module




-- It would be neat for each separate source directory to have a descriptor
-- for how we want them to compile, and then have a super generalized lua file
-- read those to compile everything.
-- There is one problem though, which is that two outputs can share source files.
-- I was considering having everything just be shared source files and then flags
-- further determine separation via in-source preprocessor guards, etc.
-- However, that relies on the compiler being able to remove unused code.
-- So I guess a shared source code directory is the way to go.


-- Should this be directory based or file based, where I have functions that can 
-- collect files based on directory?
-- In that case, what do we need to know? 
-- We need source files, output path, the temp stuff can probably be handled 
-- automatically. But we do need dependancies.


--[[ 
Need:
 - Source files
 - Output files
 - [name of temp dir]
 - Dependancies
 - Descriptors of output or temp types
 - flags or command modifiers


Ideally we want a way to define a function that defines how an output type
is handled.
]]--












--[[

Final build table heiarchy

build
    [target] (path)
        depend
            [dependancy] (path)
        builder (callback)
        opts
        flags (for the makefile, not the compiler)
            force_rebuild



We need a way to differentiate between
dependancies that need to be built
and dependancies that already exist.
I suppose a dependancy with no dependancies
is ready to be built, and we just look at 
the date of the existing file pointed
to by the target. And if it exists.
So alright, I guess that would do it.


But generally, I should try to add functions that will
generate this list for us.

First, we should have a function that recursively
pulls in files from a directory that will assign compiler,
generate dependancies, and set options.
We also need an output destination to generate the targets


The buildtree will be built according to the mode.


]]--
